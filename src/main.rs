//! shallow flatpak integration into pacman (as a wrapper)
// (by egnrse)

// main.rs

use clap::Parser;		// cli input parser
use colored::Colorize;	// format output strings (for the terminal)
use std::process::exit; // exit with an error

mod flatpak;
use flatpak::{FlatpakMeta, FlatpakApp};


const AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
const VERSION: &str = env!("CARGO_PKG_VERSION");
const LICENSE: &str = env!("CARGO_PKG_LICENSE");

/// return value when an unkown failure within this program or within called programs occurs
const EXIT_ERROR: i32 = 255;

/// store (user) settings
struct Config {
	wrap_pacman: bool,
	speed:		bool,
	color:		bool,
}
/// standart values for the settings
impl Default for Config {
	fn default() -> Self {
		Self {
			wrap_pacman: true,
			speed:		false,
			color:		true,
		}
	}
}


/// message strings for eg. -Qi fields, --help
mod messages {
	use indoc::indoc;	// multiline strings

	/// field was skipped, because of the config.speed flag
	pub const SKIPPED: &str = "[skipped]";
	/// field not implemented
	pub const NOT_IMPLEMENTED: &str = "[not Implemented]";
	/// field not implemented
	pub const NONE: &str = "None";
	/// help/usage message
	pub const HELP_USAGE: &str = indoc! {r#"
		usage: pacpak <operation> [...]
		operations:
			{-h --help}
			{-V --version}
			TODO	//dev
	"#};
}

/// read pacman like command line arguments
#[derive(Parser)]
#[command(
	disable_help_flag = true,
	group(
	clap::ArgGroup::new("operation")
		.args(&["database", "query", "sync", "remove", "deptest", "upgrade", "files", "version", "help"])
		.required(true)
))]
struct Cli {
	/// # Operations:
	/// Operate on the database
	#[arg(short = 'D', long = "database", action = clap::ArgAction::SetTrue)]
	database: bool,
	/// Query the database
	#[arg(short = 'Q', long = "query", action = clap::ArgAction::SetTrue)]
	query: bool,
	/// Remove packages
	#[arg(short = 'R', long = "remove", action = clap::ArgAction::SetTrue)]
	remove: bool,
	/// Synchronize packages
	#[arg(short = 'S', long = "sync", action = clap::ArgAction::SetTrue)]
	sync: bool,
	/// Check dependencies
	#[arg(short = 'T', long = "deptest", action = clap::ArgAction::SetTrue)]
	deptest: bool,
	/// Upgrade or add packages
	#[arg(short = 'U', long = "upgrade", action = clap::ArgAction::SetTrue)]
	upgrade: bool,
	/// Query the files database
	#[arg(short = 'F', long = "files", action = clap::ArgAction::SetTrue)]
	files: bool,
	/// Display version and exit
	#[arg(short = 'V', long = "version", action = clap::ArgAction::SetTrue)]
	version: bool,

	// custom help (autogenerated help is disabled)
	#[arg(short = 'h', long = "help", action = clap::ArgAction::SetTrue)]
	help: bool,

	
	/// # Options for operations:
	/// Display information (for a package)
	#[arg(short = 'i', long = "info", action = clap::ArgAction::SetTrue)]
	info: bool,
	/// List files (of a package)
	#[arg(short = 'l', long = "list", action = clap::ArgAction::SetTrue)]
	list: bool,
	/// Seach the package that owns the given file
	#[arg(short = 'o', long = "owns", action = clap::ArgAction::SetTrue)]
	owns: bool,
	
	//dev: more to add


	/// Targets for operations
	#[arg(value_name = "TARGETS")]
	targets: Option<String>,
}


///	outputs text similar to `pacman -Qi`
fn print_app_info(app: &FlatpakApp) {
	let mut name = String::new();
	if !app.name.is_empty() {
		name = format!("({})",app.name)
	}
	println!("{} {} {}", "Name		:".bold(),app.id, name);
	println!("{} {}", "Version		:".bold(),app.version);
	println!("{} {}", "Description	:".bold(),app.description);
	println!("{} {}", "Architecture	:".bold(),app.arch);
	println!("{} {}", "URL		:".bold(),app.url);
	println!("{} {}", "Licenses	:".bold(),app.license);
	println!("{} {}", "Groups		:".bold(),app.collection);
	println!("{} {}", "Provides	:".bold(),app.provides);
	println!("{} {}", "Depends On	:".bold(),app.depends);
	println!("{} {}", "Optional Deps	:".bold(), messages::NOT_IMPLEMENTED);
	println!("{} {}", "Required By	:".bold(),messages::NOT_IMPLEMENTED);
	println!("{} {}", "Optional For	:".bold(), messages::NOT_IMPLEMENTED);
	println!("{} {}", "Conflicts With	:".bold(), messages::NOT_IMPLEMENTED);
	println!("{} {}", "Replaces	:".bold(), messages::NOT_IMPLEMENTED);
	println!("{} {}", "Installed Size	:".bold(),app.install_size);
	println!("{} {}", "Packager	:".bold(), messages::NOT_IMPLEMENTED);
	println!("{} {}", "Build Date	:".bold(),app.build_date);
	println!("{} {}", "Install Date	:".bold(),app.install_date);
	println!("{} {}", "Install Reason	:".bold(),messages::NOT_IMPLEMENTED);
	println!("{} {}", "Install Script	:".bold(),messages::NOT_IMPLEMENTED);
	println!("{} {}", "Validated By 	:".bold(),messages::NOT_IMPLEMENTED);
	println!();
	//dev
}


/// entry point
fn main() {
	let args = Cli::parse();
	let config = Config {	//dev: overwrite some fields for now
		wrap_pacman: false,
		..Default::default()
	};

	// basic operations
	if args.help {
		println!("{}", messages::HELP_USAGE);
		return;
	} else if args.version {
		if config.wrap_pacman {
			println!(" ---");
			println!(" ");
		}
		println!(" Pacpak v{} - {} License", VERSION, LICENSE);
		println!(" Copyright (C) 2025 {}", AUTHORS);
		return;
	}

	// init flatpak metadata
	let mut flatpak = FlatpakMeta::default();
	// update flatpak app list
	match flatpak.get_apps() {
		Ok(apps) => apps,
		Err(e) => {
			println!("Error: {}", e);
			exit(EXIT_ERROR);
		}
	};
	
	// other operations
	if args.query {
		if args.info {
			let idx: usize = 0;		//dev: get the right index
			match flatpak.get_app_info(idx) {
				Ok(app) => app,
				Err(e) => {
					println!("Error: {}", e);
					exit(EXIT_ERROR);
				}
				
			};
			print_app_info(&flatpak.apps[0]);
		} else {
			for app in &flatpak.apps {
				println!("{}", app.extid);
			}
		}
	} else if args.sync {
		println!("{}{}", "Hello, world!".bold(), " Line2".green());
	} else if args.remove {
	} else if args.database {
	} else if args.deptest {
	} else if args.upgrade {
	} else if args.files {
	}

	//println!("{}", "Hello, world!".blue());
	//println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}
