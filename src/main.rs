//! shallow flatpak integration into pacman (as a wrapper)
// (by egnrse)

// main.rs

use clap::Parser;		// cli input parser
use colored::Colorize;	// format output strings (for the terminal)
use std::process::exit; // exit with an error

mod flatpak;
use flatpak::FlatpakMeta;


const AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
const VERSION: &str = env!("CARGO_PKG_VERSION");
const LICENSE: &str = env!("CARGO_PKG_LICENSE");

/// return value when an unkown failure within this program or within called programs occurs
const EXIT_ERROR: i32 = 255;

/// store (user) settings
struct Config {
	wrap_pacman: bool,
	speed:		bool,
	color:		bool,
}
/// standart values for the settings
impl Default for Config {
	fn default() -> Self {
		Self {
			wrap_pacman: true,
			speed:		false,
			color:		true,
		}
	}
}


/// message strings for eg. -Qi fields, --help
mod messages {
	use indoc::indoc;	// multiline strings

	/// field was skipped, because of the config.speed flag
	pub const SKIPPED: &str = "[skipped]";
	/// field not implemented
	pub const NOT_IMPLEMENTED: &str = "[not Implemented]";
	/// help/usage message
	pub const HELP_USAGE: &str = indoc! {r#"
		usage: pacpak <operation> [...]
		operations:
			{-h --help}
			{-V --version}
			TODO	//dev
	"#};
}

/// read pacman like command line arguments
#[derive(Parser)]
#[command(
	disable_help_flag = true,
	group(
	clap::ArgGroup::new("operation")
		.args(&["database", "query", "sync", "remove", "deptest", "upgrade", "files", "version", "help"])
		.required(true)
))]
struct Cli {
	/// # Operations:
	/// Operate on the database
	#[arg(short = 'D', long = "database", action = clap::ArgAction::SetTrue)]
	database: bool,
	/// Query the database
	#[arg(short = 'Q', long = "query", action = clap::ArgAction::SetTrue)]
	query: bool,
	/// Remove packages
	#[arg(short = 'R', long = "remove", action = clap::ArgAction::SetTrue)]
	remove: bool,
	/// Synchronize packages
	#[arg(short = 'S', long = "sync", action = clap::ArgAction::SetTrue)]
	sync: bool,
	/// Check dependencies
	#[arg(short = 'T', long = "deptest", action = clap::ArgAction::SetTrue)]
	deptest: bool,
	/// Upgrade or add packages
	#[arg(short = 'U', long = "upgrade", action = clap::ArgAction::SetTrue)]
	upgrade: bool,
	/// Query the files database
	#[arg(short = 'F', long = "files", action = clap::ArgAction::SetTrue)]
	files: bool,
	/// Display version and exit
	#[arg(short = 'V', long = "version", action = clap::ArgAction::SetTrue)]
	version: bool,

	// custom help (autogenerated help is disabled)
	#[arg(short = 'h', long = "help", action = clap::ArgAction::SetTrue)]
	help: bool,

	
	/// # Options for operations:
	/// Display information (for a package)
	#[arg(short = 'i', long = "info", action = clap::ArgAction::SetTrue)]
	info: bool,
	/// List files (of a package)
	#[arg(short = 'l', long = "list", action = clap::ArgAction::SetTrue)]
	list: bool,
	/// Seach the package that owns the given file
	#[arg(short = 'o', long = "owns", action = clap::ArgAction::SetTrue)]
	owns: bool,
	
	//dev: more to add


	/// Targets for operations
	#[arg(value_name = "TARGETS")]
	targets: Option<String>,
}



/// entry point
fn main() {
	let args = Cli::parse();
	let config = Config {	//dev: overwrite some fields for now
		wrap_pacman: false,
		..Default::default()
	};
	let mut flatpak = FlatpakMeta::default();

	if args.help {
		println!("{}", messages::HELP_USAGE);	 //dev
		return;
	} else if args.version {
		if config.wrap_pacman {
			println!(" ---");
			println!(" ");
		}
		println!(" Pacpak v{} - {} License", VERSION, LICENSE);
		println!(" Copyright (C) 2025 {}", AUTHORS);
		return;
	}

	if args.query {
		let flatpak_apps = match flatpak.get_apps() {
			Ok(apps) => apps,
			Err(e) => {
				println!("Error: {}", e);
				exit(255);
			}
		};

		for app in &flatpak.apps {
			println!("{}", app.extid);
		}
	} else if args.sync {
		println!("{}{}", "Hello, world!".bold(), " Line2".green());
	} else if args.remove {
	} else if args.database {
	} else if args.deptest {
	} else if args.upgrade {
	} else if args.files {
	}

	println!("{}", "Hello, world!".blue());
	//println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}
