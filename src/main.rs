//! shallow flatpak integration into pacman (as a wrapper)
// (by egnrse)

use clap::Parser;
use indoc::indoc;

const AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
const VERSION: &str = env!("CARGO_PKG_VERSION");
const LICENSE: &str = env!("CARGO_PKG_LICENSE");


/// store (user) settings
struct Config {
    wrap_pacman: bool,
    speed:      bool,
    color:      bool,
}
/// standart values for the settings
impl Default for Config {
    fn default() -> Self {
        Self {
            wrap_pacman: true,
            speed:      false,
            color:      true,
        }
    }
}


/// message strings for eg. -Qi fields, --help
mod messages {
    use indoc::indoc;

    /// field was skipped, because of config.speed
    pub const SKIPPED: &str = "[skipped]";
    /// field not Implemented
    pub const NOT_IMPLEMENTED: &str = "[not Implemented]";
    /// help/usage message
    pub const HELP_USAGE: &str = indoc! {r#"
        usage: pacpak <operation> [...]
        operations:
            {-h --help}
            {-V --version}
            TODO    //dev
    "#};
}

/// read pacman like command line arguments
#[derive(Parser)]
#[command(
    disable_help_flag = true,
    group(
	clap::ArgGroup::new("operation")
		.args(&["database", "query", "sync", "remove", "deptest", "upgrade", "files", "version", "help"])
		.required(true)
))]
struct Cli {
    /// Operations:
    /// Operate on the database
    #[arg(short = 'D', long = "database", action = clap::ArgAction::SetTrue)]
	database: bool,
    /// Query the database
    #[arg(short = 'Q', long = "query", action = clap::ArgAction::SetTrue)]
	query: bool,
    /// Remove packages
    #[arg(short = 'R', long = "remove", action = clap::ArgAction::SetTrue)]
	remove: bool,
    /// Synchronize packages
    #[arg(short = 'S', long = "sync", action = clap::ArgAction::SetTrue)]
	sync: bool,
    /// Check dependencies
    #[arg(short = 'T', long = "deptest", action = clap::ArgAction::SetTrue)]
	deptest: bool,
    /// Upgrade or add packages
    #[arg(short = 'U', long = "upgrade", action = clap::ArgAction::SetTrue)]
	upgrade: bool,
    /// Query the files database
    #[arg(short = 'F', long = "files", action = clap::ArgAction::SetTrue)]
	files: bool,
    /// Display version and exit
    #[arg(short = 'V', long = "version", action = clap::ArgAction::SetTrue)]
	version: bool,

    
    /// Options for operations:
    /// Display information
    #[arg(short = 'i', long = "info", action = clap::ArgAction::SetTrue)]
	info: bool,
    /// List files
    #[arg(short = 'l', long = "list", action = clap::ArgAction::SetTrue)]
	list: bool,


    /// Targets for operations
    #[arg(value_name = "TARGETS")]
    targets: Option<String>,

    // help gets autogenerated
    #[arg(short = 'h', long = "help", action = clap::ArgAction::SetTrue)]
	help: bool,
}

/// entry point
fn main() {
    let args = Cli::parse();
    let config = Config {   //dev: overwrite some fields for now
        wrap_pacman: false,
        ..Default::default()
    };

    if args.help {
        println!("{}", messages::HELP_USAGE);    //dev
        return;
    } else if args.version {
        if config.wrap_pacman {
            println!(" ---");
            println!(" ");
        }
        println!(" Pacpak v{} - {} License", VERSION, LICENSE);
        println!(" Copyright (C) 2025 {}", AUTHORS);
        return;
    }

    println!("Hello, world!");
    //println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}
